【Android开发学习】面试真题宝典整理
==================================
(常问考题解析整理)[https://www.bilibili.com/video/BV1nC4y1b7E2?p=1 "B站链接"]

安卓四大组件
------------
1. Activity
2. service
3. content provider
4. broadcast recevier

1.Activity, window, view有什么关联和区别？
-----------------------------------------
Activity:--> 负责
 * 界面展示
 * 用户交互
 * 业务逻辑处理
Window:-->
 * 相当于Activity的下属，负责界面展示以及交互的职能部门, Activity的生命周期方法负责业务的处理
View:-->
 * 放在Window容器的元素，Window是View的载体，View是Window的具体展示
差别：
Activity通过Window来实现视图元素的展示, Window可以理解为一个容器，盛放着一个个的View。

2.Handler引起的内存泄漏的原因
----------------
* Handler允许我们发送延时消息，如果在延时期间用户关闭了Activity，那么该Activity会泄漏。这个泄漏是因为Msg会持有Handler
而又因为Java的特性,内部类会持有外部类，使得Activity会被Handler持有，这样最终就导致Activity泄漏。
解决方法：
将Handler定义为静态内部类，在内部持有Activity的弱引用，并在Activity的onDestroy()中
调用handler.removeCallbacksAndMessages(null)及时移除所有消息。

3.自定义绘制是如何实施的？
----------------
* 重写onDraw()方法
Canvas定义你可以在屏幕上画的形状，而Paint为你画的每个形状定义颜色、样式、字体等等。

4.如何避免内存抖动？
--------------------

是什么？--->短时间内又大量对象进出新生区导致的,他伴随着频繁的GC，GC会大量占用UI线程和CPU资源，会导致app整体卡顿
怎么做？-->
* 尽量避免在循环体内创建对象，把对象创建移动到循环体外。
* 对于能够复用的对象,用对象池将他们缓存起来


5.应用如果发生了异常情况,怎样快速止损
---------------------------
* 功能开关
 * 出现异常时，可以紧急关闭新功能的入口
* 统跳中心
 * 设立路由跳转，跳转到统一的异常正处理中的界面
* 动态修复
 * 热修复，通过更新资源包的方式来实现动态更新
* 自助修复

6.版本迭代导致的启动变慢有好的解决方式吗？
-----------------------
* 启动器
 自动分配任务，尽量保证会平均分配在我们每一个线程中
* 结合CI
* 监控完善

android Handler机制原理解析 [https://blog.csdn.net/luoyingxing/article/details/86500542]
==========================
Handler：快递员（属于某个快递公司的职员）
Message：包裹（可以放置很多东西的箱子）
MessageQueue：快递分拣中心（分拣快递的传送带）
Looper：快递公司（具有处理包裹去向的管理中心）

一、Message
------------------------
构造方法：
```java
public Message(){}

static Message obtain()
static Message obtain(Message orig)
static Message obtain(Handler h)
```
所有的静态方法里面都会首先调用第一个方法来创建一个Message对象。
```java
	public static final Object sPoolSync = new Object();    //同步锁对象
    private static Message sPool;                           //全局池消息实例
    
	/**
     * 从全局池返回一个新的消息实例，允许我们在许多情况下避免分配新对象。
     */
    public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                //......
                return m;
            }
        }
        return new Message();
    }
```
对于其他 static obtain( ) 的重载方法，通过源码，可以发现，都是进行赋值操作，没有太多的可讨性。唯一得注意一下的是 obtain(Handler h, Runnable callback)这个静态方法：
```java
/*package*/ Handler target;
	/*package*/ Runnable callback;

	public static Message obtain(Handler h, Runnable callback) {
        Message m = obtain();
        m.target = h;
        m.callback = callback;
        return m;
    }
```














